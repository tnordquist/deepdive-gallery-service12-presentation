Integration via OAuth

Android side:
- GoogleSignInService constructor
	* Gets info from GoogleSignInService
	* requestIdToken: this means that we want to include in the returned information a token that is suitable for me to pass to a webservice that uses that same client id. This is called the audience of the resource server. Make sure we have authenticated based on that same client id. Give me a token I can present to a web service to get access to that web service.
	* Run the emulator and show the bearer token.
	
Service side: 
- Go over the fields in User again.

- UserRepository
	* Create it as interface in a dao package. It allows me to perform operations with the User entity.
	* A dao in room can deal with any entities, it doesn't matter. In Spring data require that we type it with the entity we want it to use. We must also extend an interface.
	* A bunch of methods are already defined but we do need to write our own for finding a user by oauthKey.
	* Spring data will many suggestions when we type find. Spring data will figure the sql query by camel casing that we type in. So we don't have to write the query ourselves.
	* When we says find something by it expects a parameter.
	* It selects one item based on what's passed to it. If nothing passed it will still pass the Optional but ntohing in it. The Optional was added in Java 8 to add structure to nulls. Rather than test everything for null we use the Optional to allow was to provide logic for missing values.
	* @Repository is implied becasue we extended JpaRepo.

- UserService
	* Create service package.
	* Business logic about Users goes here.
	* Right now we are just adding on method
		- If I give it an oauthKey it either looks up a User with that oauthKey or creates a user with that oauthKey.
	* Add @Service to indicate that it participates in dependency injection.
	* We need to inject UserRepository by adding @AutoWire
		- private final means add a parameter in the constructor.
		- constructors are autowired by default.
	* Add a method:
		- getOrCreate
			* findFirstbyOauthKey is an Optional that has a User or it doesn't
			* when token is presented we step in and take that infor and see if that user exists and integrate with security. 
			* It's an Optional so we need to return the required object (we could continue to chain if we wanted)
			* map says if there is an object inside that Optional I want to transform it in some way. In this case set the connected. This is a new connection.
			* orElseGet is a method of Optional that says if there is not a value then set up a User with this supplier.
- Pom
	* make sure you have data-jpa, security
	* Need to add OAuthStarter if needed
		* Add the artifactId
		* Add groupId: the oauth2 stuff.
	* Webservice can provide authentication or can be a resource server (provides REST endpoints). We are building a resource server and using Google's authentication server.
- application.yml: add security
	* Show difference in structure between this and .properties file.
	* Spring brought yml in as alternative to a flat form.
	* Add the security information.
	* issuer-uri: basically a web address where spring security can get all the infor about how to authenticate somebody.
	* client-id: the same id we put in the Android project and comes from our web client in Google. This is how Spring recognizes that the credentials presented are actually for this service. If for a different audience then the user does not get access. Must have been logged into Google for this particular client. Client-id is not particularly secret.
- Security configuration
	* create configuration package with SecurityConfiguration class.
	* Springboot walks the entire tree including finding @Configuration annotation and @EnableWebSecurity
	* WebSecurityConfigurerAdapter
	* Value injection: gets information from a resource file.
		- @value: assign a value to this field based on Spring expressions.
		- Note that the expression matches what is in yml.
		- Override configure.
			* decodes a jwt (json web token) the bearer token is about 1000 characters long. it's a jwt that's encoded. 
			* We will do some chaining:
				- First we will authorize requests. It takes as parameter an authorization object. Says that any request must be authenticated. We can customize auth based on endpoints. Authorization is different from authentication.
				- Now tell how to authenticate the user.
					* we're buidling jwt authenticated server
					* now construct an object we can work with: the converter allows us to talk to the user service.
			* jwtAuthenticationConverter: it's job is to take in a jwt and return it is as some other object that can be used for it's contents. Whatever we inject here becomes that converted to object. We're going to construct the User object here. The UserService will extend Converter and implement the override convert method for this purpose.
				- convert method in UserService:
					* Collection of SimpleGrantedAuthority: 
		- @Bean JwtDecoder: We need to verify the audience, i.e., the user has the same client id that we have.
			* To do that we need a Bean: Beans make the result of a method available for Spring to use.
			* @Bean set over JwtDecoder
				- Nimbus needs the issuer-uri that we got using 
			* Audience validator: looks at the client-id in the token to compare to our client-id.
				- takes a lambda in its constructor parameter: the client-id will be validated against our client-id.
				- By default the part above this would be validated by Google but only date and time and the issurer.
			* defaultwithissuer: 
			* now chain together the client validator and issurer validator.
				- Alot of this is cached so we don't have to keep going to Google.
			* Once we return decoder, we have enough to log in.
- UserController
	* @RequestMapping relative path to /gallery in yml
	* The principal was gotten in the convert method jwt.claim, i.e., imported from Java security. Whatever object you passed is the principal. We cast that to a User.
	* Get Bearer token from the Android side.
	* Go to Postman.
		- Put the Bearer token into the Auth section.
		- Put in the http url and GET the User information.
		- Uses the Google token to know the User sending the information. Looked at that issurer-uri to validate the sender then it decoded the information. And, if the first time, added the User to the database.
	
	* Test the log-in
		- Start the application.
								
			
	
















